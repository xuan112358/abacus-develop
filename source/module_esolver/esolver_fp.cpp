#include "esolver_fp.h"

#include "module_base/global_variable.h"
#include "module_elecstate/module_charge/symmetry_rho.h"
#include "module_hamilt_pw/hamilt_pwdft/global.h"
#include "module_io/cif_io.h"
#include "module_io/cube_io.h"
#include "module_io/json_output/init_info.h"
#include "module_io/json_output/output_info.h"
#include "module_io/output_log.h"
#include "module_io/print_info.h"
#include "module_io/rhog_io.h"
#include "module_io/write_elecstat_pot.h"
#include "module_io/write_elf.h"
#include "module_parameter/parameter.h"

namespace ModuleESolver
{

ESolver_FP::ESolver_FP()
{
    // pw_rho = new ModuleBase::PW_Basis();
    // LCAO basis doesn't support GPU acceleration on FFT currently
    std::string fft_device = PARAM.inp.device;
    if(PARAM.inp.basis_type == "lcao")
    {
        fft_device = "cpu";
    }
    pw_rho = new ModulePW::PW_Basis_Big(fft_device, PARAM.inp.precision);
    if ( PARAM.globalv.double_grid)
    {
        pw_rhod = new ModulePW::PW_Basis_Big(fft_device, PARAM.inp.precision);
    }
    else
    {
        pw_rhod = pw_rho;
    }

    // temporary, it will be removed
    pw_big = static_cast<ModulePW::PW_Basis_Big*>(pw_rhod);
    pw_big->setbxyz(PARAM.inp.bx, PARAM.inp.by, PARAM.inp.bz);
    sf.set(pw_rhod, PARAM.inp.nbspline);
}

ESolver_FP::~ESolver_FP()
{
    delete pw_rho;
    if ( PARAM.globalv.double_grid)
    {
        delete pw_rhod;
    }
    delete this->pelec;
}

void ESolver_FP::before_all_runners(UnitCell& ucell, const Input_para& inp)
{
    ModuleBase::TITLE("ESolver_FP", "before_all_runners");

    //! 1) read pseudopotentials
    if (!PARAM.inp.use_paw)
    {
        ucell.read_pseudo(GlobalV::ofs_running);
    }

    //! 2) initialie the plane wave basis for rho
#ifdef __MPI
    this->pw_rho->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD);
#endif
    if (this->classname == "ESolver_OF")
    {
        this->pw_rho->setfullpw(inp.of_full_pw, inp.of_full_pw_dim);
    }

    if (inp.nx * inp.ny * inp.nz == 0)
    {
        this->pw_rho->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, 4.0 * inp.ecutwfc);
    }
    else
    {
        this->pw_rho->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, inp.nx, inp.ny, inp.nz);
    }

    this->pw_rho->initparameters(false, 4.0 * inp.ecutwfc);
    this->pw_rho->fft_bundle.initfftmode(inp.fft_mode);
    this->pw_rho->setuptransform();
    this->pw_rho->collect_local_pw();
    this->pw_rho->collect_uniqgg();

    //! 3) initialize the double grid (for uspp) if necessary
    if ( PARAM.globalv.double_grid)
    {
        ModulePW::PW_Basis_Sup* pw_rhod_sup = static_cast<ModulePW::PW_Basis_Sup*>(pw_rhod);
#ifdef __MPI
        this->pw_rhod->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD);
#endif
        if (this->classname == "ESolver_OF")
        {
            this->pw_rhod->setfullpw(inp.of_full_pw, inp.of_full_pw_dim);
        }
        if (inp.ndx * inp.ndy * inp.ndz == 0)
        {
            this->pw_rhod->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, inp.ecutrho);
        }
        else
        {
            this->pw_rhod->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, inp.ndx, inp.ndy, inp.ndz);
        }
        this->pw_rhod->initparameters(false, inp.ecutrho);
        this->pw_rhod->fft_bundle.initfftmode(inp.fft_mode);
        pw_rhod_sup->setuptransform(this->pw_rho);
        this->pw_rhod->collect_local_pw();
        this->pw_rhod->collect_uniqgg();
    }
    ModuleIO::CifParser::write(PARAM.globalv.global_out_dir + "STRU.cif",
                               ucell,
                               "# Generated by ABACUS ModuleIO::CifParser",
                               "data_?");

    //! 4) print some information
    ModuleIO::print_rhofft(this->pw_rhod, this->pw_rho, this->pw_big, GlobalV::ofs_running);

    //! 5) initialize the charge extrapolation method if necessary
    this->CE.Init_CE(PARAM.inp.nspin, ucell.nat, this->pw_rhod->nrxx, inp.chg_extrap);

    return;
}

//! Something to do after SCF iterations when SCF is converged or comes to the max iter step.
void ESolver_FP::after_scf(UnitCell& ucell, const int istep)
{
    // 0) output convergence information
    ModuleIO::output_convergence_after_scf(this->conv_esolver, this->pelec->f_en.etot);

    // 1) write fermi energy
    ModuleIO::output_efermi(this->conv_esolver, this->pelec->eferm.ef);

    // 2) update delta rho for charge extrapolation
    CE.update_delta_rho(ucell, &(this->chr), &(this->sf));

    if (istep % PARAM.inp.out_interval == 0)
    {
        // 3) write charge density
        if (PARAM.inp.out_chg[0] > 0)
        {
            for (int is = 0; is < PARAM.inp.nspin; is++)
            {
                double* data = nullptr;
                if (PARAM.inp.dm_to_rho)
                {
                    data = this->pelec->charge->rho[is];
                    this->pw_rhod->real2recip(this->pelec->charge->rho[is], this->pelec->charge->rhog[is]);
                }
                else
                {
                    data = this->pelec->charge->rho_save[is];
                    this->pw_rhod->real2recip(this->pelec->charge->rho_save[is], this->pelec->charge->rhog_save[is]);
                }
                std::string fn =PARAM.globalv.global_out_dir + "/SPIN" + std::to_string(is + 1) + "_CHG.cube";
                ModuleIO::write_vdata_palgrid(GlobalC::Pgrid,
                                              data,
                                              is,
                                              PARAM.inp.nspin,
                                              istep,
                                              fn,
                                              this->pelec->eferm.get_efval(is),
                                              &(ucell),
                                              PARAM.inp.out_chg[1],
                                              1);
                if (XC_Functional::get_func_type() == 3 || XC_Functional::get_func_type() == 5)
                {
                    fn =PARAM.globalv.global_out_dir + "/SPIN" + std::to_string(is + 1) + "_TAU.cube";
                    ModuleIO::write_vdata_palgrid(GlobalC::Pgrid,
                                                  this->pelec->charge->kin_r_save[is],
                                                  is,
                                                  PARAM.inp.nspin,
                                                  istep,
                                                  fn,
                                                  this->pelec->eferm.get_efval(is),
                                                  &(ucell));
                }
            }
        }
        if (PARAM.inp.out_chg[0] != -1)
        {
            std::complex<double>** rhog_tot = (PARAM.inp.dm_to_rho)? this->pelec->charge->rhog : this->pelec->charge->rhog_save;
            double** rhor_tot = (PARAM.inp.dm_to_rho)? this->pelec->charge->rho : this->pelec->charge->rho_save;
            for (int is = 0; is < PARAM.inp.nspin; is++)
            {
                this->pw_rhod->real2recip(rhor_tot[is], rhog_tot[is]);
            }
            ModuleIO::write_rhog(PARAM.globalv.global_out_dir + PARAM.inp.suffix + "-CHARGE-DENSITY.restart",
                                 PARAM.globalv.gamma_only_pw || PARAM.globalv.gamma_only_local,
                                 this->pw_rhod,
                                 PARAM.inp.nspin,
                                 ucell.GT,
                                 rhog_tot,
                                 GlobalV::MY_POOL,
                                 GlobalV::RANK_IN_POOL,
                                 GlobalV::NPROC_IN_POOL);
        }

        // 4) write potential
        if (PARAM.inp.out_pot == 1 || PARAM.inp.out_pot == 3)
        {
            for (int is = 0; is < PARAM.inp.nspin; is++)
            {
                std::string fn =PARAM.globalv.global_out_dir + "/SPIN" + std::to_string(is + 1) + "_POT.cube";

                ModuleIO::write_vdata_palgrid(GlobalC::Pgrid,
                                              this->pelec->pot->get_effective_v(is),
                                              is,
                                              PARAM.inp.nspin,
                                              istep,
                                              fn,
                                              0.0, // efermi
                                              &(ucell),
                                              3,  // precision
                                              0); // out_fermi
            }
        }
        else if (PARAM.inp.out_pot == 2)
        {
            std::string fn =PARAM.globalv.global_out_dir + "/ElecStaticPot.cube";
            ModuleIO::write_elecstat_pot(
#ifdef __MPI
                this->pw_big->bz,
                this->pw_big->nbz,
#endif
                fn,
                istep,
                this->pw_rhod,
                this->pelec->charge,
                &(ucell),
                this->pelec->pot->get_fixed_v());
        }

        // 5) write ELF
        if (PARAM.inp.out_elf[0] > 0)
        {
            this->pelec->charge->cal_elf = true;
            Symmetry_rho srho;
            for (int is = 0; is < PARAM.inp.nspin; is++)
            {
                srho.begin(is, *(this->pelec->charge), this->pw_rhod, ucell.symm);
            }

            std::string out_dir =PARAM.globalv.global_out_dir;
            ModuleIO::write_elf(
#ifdef __MPI
                this->pw_big->bz,
                this->pw_big->nbz,
#endif
                out_dir,
                istep,
                PARAM.inp.nspin,
                this->pelec->charge->rho,
                this->pelec->charge->kin_r,
                this->pw_rhod,
                &(ucell),
                PARAM.inp.out_elf[1]);
        }
    }
}

void ESolver_FP::before_scf(UnitCell& ucell, const int istep)
{
    ModuleBase::TITLE("ESolver_FP", "before_scf");

    if (ucell.cell_parameter_updated)
    {
        // only G-vector and K-vector are changed due to the change of lattice
        // vector FFT grids do not change!!
        pw_rho->initgrids(ucell.lat0, ucell.latvec, pw_rho->nx, pw_rho->ny, pw_rho->nz);
        pw_rho->collect_local_pw();
        pw_rho->collect_uniqgg();

        if (PARAM.globalv.double_grid)
        {
            this->pw_rhod->initgrids(ucell.lat0, ucell.latvec, pw_rhod->nx, pw_rhod->ny, pw_rhod->nz);
            this->pw_rhod->collect_local_pw();
            this->pw_rhod->collect_uniqgg();
        }

        this->p_locpp->init_vloc(this->pw_rhod);
        ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, "LOCAL POTENTIAL");

        this->pelec->omega = ucell.omega;

        if (ModuleSymmetry::Symmetry::symm_flag == 1)
        {
            ucell.symm.analy_sys(ucell.lat, ucell.st, ucell.atoms, GlobalV::ofs_running);
            ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, "SYMMETRY");
        }

        kv.set_after_vc(PARAM.inp.nspin, ucell.G, ucell.latvec);
        ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, "INIT K-POINTS");
    }

    return;
}

} // namespace ModuleESolver
